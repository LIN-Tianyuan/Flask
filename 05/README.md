# Request Hooks and Contexts
## 1. Exception handling
### 1.1 HTTP exceptions are actively thrown
 - The abort method
   - Throws an HTTPException with a given status code or a specified response
   - For example to terminate the request with a page not found exception we can call abort(404).

 - Parameters:
   - code - the HTTP error status code
```python
# abort(404)
abort(500)
```
If we throw status codes, we can only throw HTTP protocol error status codes.

### 1.2 Catch errors
 - Catch error errorhandler decorator
   - Registers an error handler that calls the method decorated by this decorator when the program throws the specified error status code
 - Parameters:
   - code_or_exception - HTTP error status code or specified exception
 - For example, uniformly handles errors with status code 500 to give the user a friendly hint:
```python
@app.errorhandler(500)
def internal_server_error(e):
    return "The server's moved."
```
 - Catch specified exceptions
```python
@app.errorhandler(ZeroDivisionError)
def zero_division_error(e):
    return 'The divisor cannot be 0.'
```

## 2. Request Hooks
There are some preparatory or sweeping tasks that need to be handled during the client-server interaction, such as:

 - Establishing a database connection at the beginning of the request;
 - At the beginning of the request, performing permission checks as required;
 - At the end of the request, specifying the format of the data interaction.

In order for each view function to avoid writing code that duplicates functionality, Flask provides the functionality of a generic facility, the request hook.

Request hooks are implemented in the form of decorators. Flask supports the following four types of request hooks:

 - before_first_request
   - Executes before the first request is processed

 - before_request
   - Execute before each request
   - If a response is returned in a modified function, the view function will no longer be called

 - after_request
   - Execute after each request if no error is thrown
   - Takes one argument: the response from the view function
   - The response can be modified in this function as a final step before being returned.
   - Need to return the response in this parameter.

 - teardown_request
   - Executed after each request
   - Accepts one parameter: an error message to be thrown if there is a relevant error.

**Code test**
```python
from flask import Flask

app = Flask(__name__)


# Called before the first request, you can do some initialization inside this method
@app.before_first_request
def before_first_request():
   print("before_first_request")


# Called before each request, when a request has already been made, it may be possible to do the request validation inside this method
# If the verification of the request is unsuccessful, you can respond directly in this method, directly after the return then the view function will not be executed
@app.before_request
def before_request():
   print("before_request")
   # if Requests ineligible:
   #     return "Ineligible"


# Will be called after the execution of the view function, and the response generated by the view function will be passed in, you can do the last step of unified processing of the response in this method
@app.after_request
def after_request(response):
   print("after_request")
   response.headers["Content-Type"] = "application/json"
   return response


# Please call it after every request, it will accept a parameter which is an error message from the server
@app.teardown_request
def teardown_request(response):
   print("teardown_request")


@app.route('/')
def index():
   return 'index'


if __name__ == '__main__':
   app.run(debug=True)
```
 - Printing on the 1st request:
```bash
before_first_request
before_request
after_request
teardown_request
```
 - Printing on the 2nd request:
```bash
before_request
after_request
teardown_request
```
## 3. Context
Context: semantics, in the program can be understood in the code execution to a certain moment, according to the previous code to do the operation and the following logic to be executed, we can decide in the current moment to use to the variables, or can be completed things.

There are two types of contexts in Flask, the request context and the application context.

Context object in Flask: It is equivalent to a container that holds some information about the running process of the Flask program.

### 3.1 Request context
In the view function, how to fetch the data related to the current request? For example: request address, request method, cookie, etc.

In flask, we can use the **request** object directly in the view function to get the relevant data, and **request** is the request context object, which saves the relevant data of the current request, the request context object are: request, session

 - request
   - Encapsulates the content of an HTTP request, for an http request. 
   - Example: user = request.args.get('user'), gets the parameters of the get request.

 - session
   - Used to record the information in the request session, for the user information. 
   - Example: session['name'] = user.id, which can record user information. User information can also be obtained via session.get('name').

### 3.2 Application context
Application context, but it does not always exist, it is just a request context of the app's agent (people), the so-called local proxy. Its role is mainly to help the request to get the current application. It is born with the request and dies with the request.

The application context objects are: current_app, g

**current_app**

Application context, used to store variables in the application, we can print the name of the current app via current_app.name, or we can store some variables in current_app, for example:
 - Which file is the application's startup script, and which parameters are specified at startup
 - Which configuration files were loaded and imported
 - Which database is connected
 - What public utility classes and constants are available?
 - Which machine the application is running on, what IP address it has, and how much memory it has.

**Example**

Create `current_app_demo.py`
```python
from flask import Flask, current_app

app1 = Flask(__name__)
app2 = Flask(__name__)

# Take the redis client object as an example
# Represent the created redis client as a string.
# Save the created redis client object to the flask app for ease of use in individual views.
# Later we can use current_app.redis_cli to get it in the view
app1.redis_cli = 'app1 redis client'
app2.redis_cli = 'app2 redis client'

@app1.route('/route11')
def route11():
    return current_app.redis_cli

@app1.route('/route12')
def route12():
    return current_app.redis_cli

@app2.route('/route21')
def route21():
    return current_app.redis_cli

@app2.route('/route22')
def route22():
    return current_app.redis_cli
```
Run
```bash
export FLASK_APP=current_app_demo:app1
flask run
```
 - Visit `/route11` show `app1 redis client`
 - Visit `/route12` show `app1 redis client`

```bash
export FLASK_APP=current_app_demo:app2
flask run
```
- Visit `/route21` show `app2 redis client`
- Visit `/route22` show `app2 redis client`

**Role**

**`current_app` is the currently running flask app, in the code is not convenient to directly manipulate the flask app object, we can operate the `current_app` is equivalent to operate the flask app object.**

**g object**

g serves as a temporary global variable in the flask program, acting as an intermediary through which we can pass some data between multiple functions called in a single request. This variable is reset for each request.

**Example**
```python
from flask import Flask, g

app = Flask(__name__)

def db_query():
    user_id = g.user_id
    user_name = g.user_name
    print('user_id={} user_name={}'.format(user_id, user_name))

@app.route('/')
def get_user_profile():
    g.user_id = 123
    g.user_name = 'alex'
    db_query()
    return 'hello world'
```

**Integrated case of g-objects and request hooks**

**Requirement**
 - Building Authentication Mechanisms
 - For specific views we can provide restrictions that force the user to log in
 - For all views, attempts can be made in the view to obtain the user's authenticated identity, regardless of whether the user is forced to log in or not

**Realisation**
```python
from flask import Flask, abort, g

app = Flask(__name__)

@app.before_request
def authentication():
    """
    Use the before_request request hook to try to determine the user's identity before entering all views
    :return:
    """
    # TODO This utilizes authentication mechanisms (e.g., cookies, session, jwt, etc.) to identify user identity information
    # if Logged user, user has identity information
    g.user_id = 123
    # else Not logged user, user has no identity information
    # g.user_id = None

def login_required(func):
    def wrapper(*args, **kwargs):
        if g.user_id is not None:
            return func(*args, **kwargs)
        else:
            abort(401)

    return wrapper

@app.route('/')
def index():
    return 'home page user_id={}'.format(g.user_id)

@app.route('/profile')
@login_required
def get_user_profile():
    return 'user profile page user_id={}'.format(g.user_id)
```

### 3.3 app_context and request_context
Is it a problem to use the objects `current_app`, `g`, and `request` when debugging code without the Flask program running? How should we use them?

**app_context**

`app_context` provides us with the application context environment, allowing us to externally use the application contexts `current_app`, `g`

This can be done with the `with` statement

```bash
>>> from flask import Flask
>>> app = Flask('')
>>> app.redis_cli = 'redis client'
>>> 
>>> from flask import current_app
>>> current_app.redis_cli   # Error, no context
Error
>>> with app.app_context():  # Creating an application context using app_context with the help of the with statement
...     print(current_app.redis_cli)
...
redis client
```

**request_context**

`request_context` provides us with the request context environment, allowing us to use the request context externally `request`, `session`

This can be done with the `with` statement

```bash
>>> from flask import Flask
>>> app = Flask('')
>>> request.args  # Error, no context
Error
>>> environ = {'wsgi.version':(1,0), 'wsgi.input': '', 'REQUEST_METHOD': 'GET', 'PATH_INFO': '/', 'SERVER_NAME': 'alex server', 'wsgi.url_scheme': 'http', 'SERVER_PORT': '80'}  # Simulate parsing wsgi dictionary data after a client request
>>> with app.request_context(environ):  # Creating a request context using request_context with the help of the with statement
...     print(request.path)
...   
```

